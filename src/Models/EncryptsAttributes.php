<?php

namespace DarkGhostHunter\Laratraits\Models;

use Illuminate\Encryption\Encrypter;

/**
 * Trait EncryptsAttributes
 * ---
 * This trait allows to encrypt and decrypt attributes, using an autogenerated key. The usage is very simple:
 *
 * 1. Register a Key Resolver that retrieves the key from somewhere if present. A default is registered.
 * 2. Set the encryptable attributes.
 * 3. Save the model. When this is done, these attributes will be automatically encrypted.
 * 4. Retrieve the Key and show it to the User.
 *
 * 1. Retrieve the Model.
 * 2. The key resolver will be called to retrieve the key from somewhere (like the request or the session).
 * 3. The attributes will be decrypted.
 *
 * @package DarkGhostHunter\Laratraits\Models
 */
trait EncryptsAttributes
{
    /**
     * The logic that retrieves the key to decrypt the attributes.
     *
     * @var callable
     */
    protected static $keyResolver;

    /**
     * Encrypter instance.
     *
     * @var \Illuminate\Encryption\Encrypter
     */
    protected $encrypter;

    /**
     * The list of attributes to encrypt and decrypt.
     *
     * @var array
     */
    protected $encryptableAttributes = [];

    /**
     * The list of encrypted attributes. This avoids encrypting them again.
     *
     * @var array
     */
    protected $encryptedAttributes = [];

    /**
     * Registers a key resolving callable
     *
     * @param  callable  $callable
     */
    public static function registerKeyResolver(callable $callable)
    {
        static::$keyResolver = $callable;
    }

    /**
     * Boot the current trait.
     *
     * @return void
     */
    protected static function bootEncryptsAttributes()
    {
        if (! static::$keyResolver) {
            static::$keyResolver = function () {
                return request('encryption_key') ?? session('encryption_key');
            };
        }

        static::saving(function ($model) {
            $model->encryptAttributes();
        });

        static::retrieved(function ($model) {
            $model->markAllAttributesAsEncrypted();
            $model->decryptAttributes();
        });
    }

    /**
     * Initialize the current trait.
     *
     * @return void
     */
    protected function initializeEncryptsAttributes()
    {
        $this->encryptedAttributes = array_fill_keys(array_keys($this->encryptableAttributes), false);
    }

    /**
     * Marks all the attributes as Encrypted when retrieving the Model.
     *
     * @return void
     */
    public function markAllAttributesAsEncrypted()
    {
        $this->encryptableAttributes = array_fill_keys(array_keys($this->encryptableAttributes), false);
    }

    /**
     * Encrypts the attributes marked as encryptable.
     *
     * @return $this
     */
    public function encryptAttributes()
    {
        foreach ($this->encryptableAttributes as $attribute) {
            $this->encryptAttribute($attribute);
        }

        return $this;
    }

    /**
     * Encrypts and sets attribute.
     *
     * @param  string  $attribute
     * @return string
     */
    public function encryptAttribute(string $attribute)
    {
        if ($this->encryptedAttributes[$attribute]) {
            return $this->getAttribute($attribute);
        }

        $encrypted = $this->encrypter()->encrypt($this->getAttribute($attribute));

        $this->setAttribute($attribute, $encrypted);

        $this->encryptedAttributes[$attribute] = true;

        return $encrypted;
    }

    /**
     * Decrypts the attributes marked as encryptable.
     *
     * @return $this
     */
    public function decryptAttributes()
    {
        foreach ($this->encryptableAttributes as $attribute) {
            $this->decryptAttribute($attribute);
        }

        return $this;
    }

    /**
     * Decrypts and sets attribute
     *
     * @param  string  $attribute
     * @return mixed
     */
    public function decryptAttribute(string $attribute)
    {
        if (! $this->encryptedAttributes[$attribute]) {
            return $this->getAttribute($attribute);
        }

        $decrypted = $this->encrypter()->decrypt($this->getAttribute($attribute));

        $this->setAttribute($attribute, $decrypted);

        $this->encryptedAttributes[$attribute] = false;

        return $decrypted;
    }

    /**
     * Returns the encrypter instance
     *
     * @return \Illuminate\Encryption\Encrypter
     */
    public function encrypter()
    {
        return $this->encrypter = $this->encrypter ?? app(Encrypter::class, [
            'key' => app()->call(static::$keyResolver) ?? Encrypter::generateKey($this->encrypterCypher())
        ]);
    }

    /**
     * Return the cypher to use for the encrypter.
     *
     * @return string
     */
    public function encrypterCypher()
    {
        return 'AES-128-CBC';
    }

    /**
     * Return the key used to encrypt/decrypt.
     *
     * @return string
     */
    public function getEncrypterKey()
    {
        return $this->encrypter()->getKey();
    }
}
